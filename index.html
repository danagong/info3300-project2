<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 2</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <link
    href="https://fonts.googleapis.com/css?family=Aldrich|Arima+Madurai|Open Sans|Libre+Baskerville|Pirata+One|Poiret+One|Sancreek|Satisfy|Share+Tech+Mono|Smokum|Snowburst+One|Special+Elite"
    rel="stylesheet">
    <style>
      body{
        font-family: "Open Sans";
      }
    </style>

</head>
<body>
  <h3> Trees and Air Quality in an Urban World</h3>
    <svg id="nyc-choropleth" height="700" width="1200" >
    </svg>
</body>

<script>
const svg = d3.select("#nyc-choropleth");
  const width = svg.attr("width");
  const height = svg.attr("height");
  const margin = { top: 20, right: 20, bottom: 20, left:20};
  const mapWidth = width - margin.left - margin.right;
  const mapHeight = height - margin.top - margin.bottom;
  const map = svg.append("g")
                  .attr("transform","translate("+margin.left+","+margin.top+")");


const requestData = async function() {


  const nyc = await d3.json("map.geojson");
  const trees = await d3.csv("trees.csv");
  const air = await d3.csv("air.csv");
  console.log(nyc);
  console.log(trees);
  console.log(air);

  var AirDict = {};
  air.forEach(d => {
      AirDict[d['community_district'] ] = d['particle_concentration'] 
  });

  airExtent = d3.extent(air, d => Number(d['particle_concentration']));
  let airColorScale = d3.scaleLinear()
    .domain(airExtent)
    .range(['turquoise','navy']);

  console.log(airExtent);
  
  var projection = d3.geoAlbers()
    .fitSize([mapWidth, mapHeight], nyc)


  const path = d3.geoPath(projection);

  const airScale = d3.scaleQuantile().domain([7,14]).range([1,.8,.5,.3,.15]);
  // creating NYC neighborhood/borough map
  var viewport = map.append("g");

  var areas = viewport.selectAll( "path" )
    .data( nyc.features )
    .enter()
    .append( "path" ) 
    .attr("class","outline")
    .style("stroke-width", 1)
    .style("opacity", 1)
    .attr( "stroke", "#333")
    .attr("fill", (function (d) { 
    // Manhattan
        if(parseInt(d.properties.boro_cd)<=112 && parseInt(d.properties.boro_cd)>=101)
        
        {return airColorScale(AirDict[d.properties.boro_cd])}
      
        // Staten Island
        if(parseInt(d.properties.boro_cd)<=503 && parseInt(d.properties.boro_cd)>=501)
        {return airColorScale(AirDict[d.properties.boro_cd])}

        // Bronx
        if(parseInt(d.properties.boro_cd)<=212 && parseInt(d.properties.boro_cd)>=201)
        {return airColorScale(AirDict[d.properties.boro_cd])}

        // Brooklyn
        if(parseInt(d.properties.boro_cd)<=318 && parseInt(d.properties.boro_cd)>=301)
        {return airColorScale(AirDict[d.properties.boro_cd])}

        // Queens
        if(parseInt(d.properties.boro_cd)<=414 && parseInt(d.properties.boro_cd)>=401)
        {return airColorScale(AirDict[d.properties.boro_cd])}

        else {return "lightgrey"}
    } ))
    .attr( "d", path );

  viewport.selectAll(".pin")
    .data(trees)
    .enter().append("circle")
    .attr("class","circles")
    .attr("r",1 )
    .style("opacity", ".1")
    .attr("fill", "green")
    .attr("cx",function(d) { return projection([d["longitude"],d["latitude"]])[0];})
    .attr("cy",function(d) { return projection([d["longitude"],d["latitude"]])[1];});

  var zoom = d3.zoom()
               .scaleExtent([1,10])
               .on("zoom", mapZoomed);
  viewport.call(zoom);
  function mapZoomed({transform}) {     
    viewport.attr("transform", transform.toString());
    viewport.selectAll(".outline")
            .style("stroke-width", 1 / transform.k);
    viewport.selectAll(".circles")
            .style("r", radius(transform.k));
    viewport.selectAll(".circles")
            .style("opacity",  opa(transform.k));
  }
    
  function radius(k) {
    const rScale = d3.scaleLinear().domain([1, 10])
        .range([1, 0.5]);
    return rScale(k);
  }

  function opa(k) {
    const opaScale = d3.scaleLinear().domain([1, 10])
        .range([0.1, 0.3]);
    return opaScale(k);
  }

  let tooltip = map.append("g")
                     .attr("class","tooltip")
                     .attr("visibility","hidden");
  tooltip.append("rect")
           .attr("fill", "black")
           .attr("opacity", 1)
           .attr("x", -20)
           .attr("y", 0)
           .attr("width",180)
           .attr("height",40)
  let textbox = tooltip.append("text")
                     .text('halo')
                     .attr("fill", "white")
                     .attr("text-anchor","middle")
                     .attr("alignment-baseline","hanging")
                     .attr("x", 60)
                     .attr("y", 2);
  let textbox2 = tooltip.append("text")
                    .attr("fill", "white")
                    .attr("text-anchor","middle")
                    .attr("alignment-baseline","hanging")
                    .attr("x", 60)
                    .attr("y", 22);


  areas.on("mouseover", function() {
    tooltip.style("visibility","visible")
    current = d3.select(this);
    current.style("stroke-width", 3)
    let title = d3.select(this).datum().properties.boro_cd;
    textbox.text("Community: " + title)
      .attr("font-size","15px");
    textbox2.text("Air Particles: " + String(AirDict[title]).slice(0, 5))
      .attr("font-size","15px");
    let bounds = path.bounds( current.datum() )
    let xPos = (bounds[0][0]+bounds[1][0])/2.0 + 50;
    let yPos = (bounds[1][1] - 50);
    tooltip.attr("transform",`translate(${xPos},${yPos})`);
  });

  areas.on("mouseout", function() {
    tooltip.style("visibility","hidden")
    textbox.html('');
    textbox2.html('');
    current = d3.select(this);
    current.style("stroke-width", 1)
  });
};

requestData();
</script>
<h3> Trees and Population Scatter Plot</h3>
<svg id="nyc-scatterplot" height="700" width="1200" ></svg>
<script>
  const svg2 = d3.select("#nyc-scatterplot");
  const width2 = svg2.attr("width");
  const height2 = svg2.attr("height");
  const margin2 = { top: 30, right: 50, bottom: 50, left:80};
  const mapWidth2 = width2 - margin2.left - margin2.right;
  const mapHeight2 = height2 - margin2.top - margin2.bottom;
  const scatterPlot = svg2.append("g")
                  .attr("transform","translate("+margin2.left+","+margin2.top+")");

                  
const requestData2 = async function() {

  const trees2 = await d3.csv("trees.csv");
  const nycData = await d3.csv("nyc_zip_borough_neighborhoods_pop.csv");
  
  
  let blockTreeNum = {};
  let blockPopulation = {};
  for(let i=0; i<trees2.length;i++)
  {
    if (!blockTreeNum[trees2[i].postcode]){
      blockTreeNum[trees2[i].postcode] = 0;
    }

    blockTreeNum[trees2[i].postcode]+=1;

  }
  for(let i=0; i<nycData.length;i++)
  {
    
    blockPopulation[nycData[i].zip]=nycData[i].population;

  }
  //x Scale 
  const treeExtent = d3.extent(Object.values(blockTreeNum));
  const treeScale = d3.scaleLinear().domain(treeExtent).range([0, mapWidth2]);
  let bottomAxis = d3.axisBottom(treeScale).ticks(6)
  svg2.append('g')
      .attr('class', 'x axis')
      .attr('transform',`translate(${margin2.left},${mapHeight2+margin2.top})`)
      .call(bottomAxis);
  let bottomGridlines = d3.axisBottom(treeScale)
                          .tickSize(-mapHeight2)
                          .tickFormat('')
                          .ticks(6);
  svg2.append('g').attr('class', 'x gridlines')
                  .attr('transform',`translate(${margin2.left},${mapHeight2+margin2.top})`)
                  .call(bottomGridlines);

  //y Scale
  pop_data = (d3.map(nycData,d=>d.population)).map(Number)
  
  const popExtent = d3.extent(pop_data);
  const popScale = d3.scaleLinear().domain(popExtent).range([mapHeight2, 0]);
  let leftAxis = d3.axisLeft(popScale);
  svg2.append('g')
      .attr('class', 'y axis')
      .attr('transform',`translate(${margin2.left},${margin2.top})`) 
      .call(leftAxis);
  let leftGridlines = d3.axisLeft(popScale)
                      .tickSize(-mapWidth2)
                      .tickFormat('');
  svg2.append('g').attr('class', 'y gridlines')
            .attr('transform',`translate(${margin2.left},${margin2.top})`)
            .call(leftGridlines);
  // data point
  Object.keys(blockTreeNum).forEach((d,i)=>
  {
    scatterPlot.append('circle')
                .attr('cx', treeScale(blockTreeNum[d]))
                .attr('cy', popScale(Number(blockPopulation[d])))
                .attr('r', 5)
                .attr('opacity', 0.5)
                .attr('index', i)
                .style('fill', 'darkblue');
  });
  svg2.append("text")
    .attr("class", "x label")
    .attr("text-anchor", "end")
    .attr("x", width2/2)
    .attr("y", height2-10)
    .text("Number of trees in a zipcode block");
  svg2.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0)
      .attr("x",0 - (height2 / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Population in a zipcode block");
  
    

};//finish request data
requestData2();

</script>
</html>