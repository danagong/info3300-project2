<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 2</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <link
    href="https://fonts.googleapis.com/css?family=Aldrich|Arima+Madurai|Open Sans|Libre+Baskerville|Pirata+One|Poiret+One|Sancreek|Satisfy|Share+Tech+Mono|Smokum|Snowburst+One|Special+Elite"
    rel="stylesheet">
    <style>
      body{
        font-family: "Open Sans";
        background-color:lightyellow"
      }
      .tooltip {
        pointer-events: none;
      }
      .tree {
        pointer-events: none;
      }
      .flex-row{
        display: flex;
        flex-direction: row;
      }
 
    </style>

</head>
<body>
 
  <div class="flex-row">
    <div>
      <h3> Trees and Air Quality in an Urban World</h3>
      <p> Graph 1: A Map of NY with the distribution of trees. Each green circle of the map represents an individual tree. 
          The map is colored accorrding to the air particles in the corresponding community district. The legend above shows
          The scale for coloring. Hover, zoom and pan on the map to find out more information about each districts.
      </p>
      <div class ="plot">
        <svg id="nyc-choropleth" height="600" width="800" ></svg>
        <h5> Air Quality Scale</h5>
        <svg id="colorLegend" height="100" width="400" style="background: #fff; margin-top:30px" ></svg>
      </div>
    </div>
    <div>
      <div class ="plot">
        <h3> Trees and Poverty Rate Scatter Plot</h3>
        <p> Graph 2: A scatterplot of NY communities with X axis as its count of trees and Y axis as its poverty rate, the
            circles are colored by their borough. Zoom and pan on the map to see the circle's precise points on the plot.
        </p>
        <svg id="nyc-scatterplot" height="300" width="560" ></svg>
      </div>
    </div>
  </div>
</body>

<script>
  // Set up map svg
  const svg = d3.select("#nyc-choropleth");
  const width = svg.attr("width");
  const height = svg.attr("height");
  const margin = { top: 20, right: 20, bottom: 20, left:20};
  const mapWidth = width - margin.left - margin.right;
  const mapHeight = height - margin.top - margin.bottom;
  const map = svg.append("g").attr("transform","translate("+margin.left+","+margin.top+")");

  //scatterplot1 Poverty vs trees
  const svg2 = d3.select("#nyc-scatterplot");
  const width2 = svg2.attr("width");
  const height2 = svg2.attr("height");
  const margin2 = { top: 30, right: 80, bottom: 40, left:50};
  const mapWidth2 = width2 - margin2.left - margin2.right;
  const mapHeight2 = height2 - margin2.top - margin2.bottom;

  const scatterPlot = svg2.append("g")
                  .attr("transform","translate("+margin2.left+","+margin2.top+")");
  let viewport2 = scatterPlot.append("g");

  // let instructions = map.append("g").attr("transform", "translate(50, 20)");

  // instructions.append("rect")
  //           .attr("fill", "lightgreen")
  //           .attr("class", "instructions")
  //           .attr("width", 350)
  //           .attr("height", 200);
  
  // instructions.append("text")
  //             .attr("alignment-baseline","hanging")
  //             .attr("x", 100)
  //             .attr("y", 20)
              //.text("Instruction Block:");

  // let legend = map.append("g").attr("transform", "translate(50, 250)");

  const requestData = async function() {

    const trees2 = await d3.csv("data/trees.csv");
    const nycData = await d3.csv("data/neighborhood_income.csv");
    console.log(nycData)
    //Map BX10 to 210, and so on
    let CD_to_num = {"BX":"2","BK":"3","MN":"1","QN":"4","SI":"5"}
    let blockTreeNum = {};
    let blockPopulation = {};
    let blockBorough = {};
    for(let i=0; i<trees2.length;i++)
    {
      let CD_num = CD_to_num[trees2[i].nta.slice(0,2)]+trees2[i].nta.slice(-2)
      if (!blockTreeNum[CD_num]){
        blockTreeNum[CD_num] = 0;
      }
      blockTreeNum[CD_num]+=1;
      blockBorough[CD_num]=(trees2[i].borough);
    }
    let CDCode = "";
    let CDOriginal = "";
    //translate 
    for(let i=0; i<nycData.length;i++)
    {
      CDOriginal = nycData[i].CD.split(' ');
      
      if ((CDOriginal[3].length)==1) 
      {
        CDCode = CD_to_num[CDOriginal[0]]+"0"+CDOriginal[3];
      }
      else CDCode = CD_to_num[CDOriginal[0]]+CDOriginal[3];
      blockPopulation[CDCode.toString()]=Number(nycData[i].NYC_Poverty_Rate);

      if ((CDOriginal.length)==6) 
      {
        if ((CDOriginal[5].length)==1) 
        {
          CDCode = CD_to_num[CDOriginal[0]]+"0"+CDOriginal[5];
        }
        else CDCode = CD_to_num[CDOriginal[0]]+CDOriginal[5];
      }
      blockPopulation[CDCode.toString()]=Number(nycData[i].NYC_Poverty_Rate);
    }
    console.log(blockPopulation)
    console.log(blockTreeNum)
    const treeExtent = d3.extent(Object.values(blockTreeNum));
    const treeScale = d3.scaleLinear().domain([0,1530]).range([0, mapWidth2]);
    let bottomAxis = d3.axisBottom(treeScale).ticks(6)
    svg2.append('g')
        .attr('class', 'x axis')
        .attr('transform',`translate(${margin2.left},${mapHeight2+margin2.top})`)
        .call(bottomAxis);
    let bottomGridlines = d3.axisBottom(treeScale)
                            .tickSize(-mapHeight2)
                            .tickFormat('')
                            .ticks(6);
    svg2.append('g').attr('class', 'x gridlines')
                    .attr('transform',`translate(${margin2.left},${mapHeight2+margin2.top})`)
                    .call(bottomGridlines);

    //y Scale
    pop_data = (d3.map(nycData,d=>d.NYC_Poverty_Rate)).map(Number)

    const popExtent = d3.extent(pop_data);
    const popScale = d3.scaleLinear().domain(popExtent).range([mapHeight2, 0]);
    let leftAxis = d3.axisLeft(popScale).ticks(4);
    svg2.append('g')
        .attr('class', 'y axis')
        .attr('transform',`translate(${margin2.left},${margin2.top})`) 
        .call(leftAxis);
    let leftGridlines = d3.axisLeft(popScale)
                        .tickSize(-mapWidth2)
                        .tickFormat('')
                        .ticks(4);
    svg2.append('g').attr('class', 'y gridlines')
              .attr('transform',`translate(${margin2.left},${margin2.top})`)
              .call(leftGridlines);
    // color scale
    var colorArray = [
                      "#4682B4",
                        "#ADD8E6",
                        "#FF69B4",
                        "#008000",
                        "#9933ff"
                        ];
    const colorExtent = d3.extent(trees2, d => d.borough);
    const colorScale = d3.scaleOrdinal()
                          .domain(colorExtent)//give it all the data not just extent to binning
                          .range(colorArray)
    // data point

    Object.keys(blockPopulation).forEach((d,i)=>
    {
      if(blockTreeNum[d]!=undefined){
        viewport2.append('circle')
                  .attr('cx', treeScale(blockTreeNum[d.toString()]))
                  .attr('cy', popScale(Number(blockPopulation[d.toString()])))
                  .attr('r', 4)
                  .attr('opacity', 0.9)
                  .attr('index', i)
                  .style('fill', colorScale(blockBorough[d]));

      }
      
    });
    svg2.append("text")
      .attr("class", "x label")
      .attr("text-anchor", "end")
      .attr("x", width2/2)
      .attr("y", height2-10)
      .style("font-size", "13")
      .text("Number of trees");
    svg2.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0)
        .attr("x",0 - (height2 / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .style("font-size", "13")
        .text("NYC Poverty rate");
        
    let boroughList = ['Bronx', 'Staten Island','Brooklyn','Queens','Manhattan']
    svg2.append("g").selectAll("mydots")
      .data(boroughList)
      .enter()
      .append("circle")
      .attr("cx", width2*15/17)
      .attr("cy", function(d,i){ return height2*2/3 + i*17}) // 100 is where the first dot appears. 25 is the distance between dots
      .attr("r", 3)
      .style("fill", function(d){ return colorScale(d)})
    svg2.append("g").selectAll("scatterplot text")
      .data(boroughList)
      .enter()
      .append("text")
      .attr("x", width2*15/17+5)
      .attr("y", function(d,i){ return height2*2/3+5 + i*17}) // 100 is where the first dot appears. 25 is the distance between dots
      .style("fill", function(d){ return colorScale(d)})
      .style("font-size", "10")
      .text(function(d){ return (d)});
    // console.log(colorExtent)

    var plotZoom = d3.zoom().scaleExtent([1,3]).on("zoom", plotZoomed);

    svg2.call(plotZoom);

    function plotZoomed(event) {    

      viewport2.attr("transform", event.transform);
      //cannot access circles

      leftAxis.scale(event.transform.rescaleY(popScale))
      bottomAxis.scale(event.transform.rescaleX(treeScale))
      leftGridlines.scale(event.transform.rescaleY(popScale))
      bottomGridlines.scale(event.transform.rescaleX(treeScale))

      d3.select("g.y.axis").call(leftAxis);
      d3.select("g.x.axis").call(bottomAxis);
      d3.select("g.y.gridlines").call(leftGridlines);
      d3.select("g.x.gridlines").call(bottomGridlines);
    }

    // Add one dot in the legend for each name.
    svg2.selectAll("mylabels")
      .data(boroughList)
      .enter()
      .append("text")
      .attr("x", 120)
      .attr("y", function(d,i){ return 620 + i*17}) // 100 is where the first dot appears. 25 is the distance between dots
      .style("fill", function(d){ return colorScale(d)})
      .text(function(d){ return d})
      .attr("text-anchor", "left")
      .style("alignment-baseline", "middle")


    // Import data sets
    const nyc = await d3.json("data/map.geojson");
    const trees = await d3.csv("data/trees.csv");
    const air = await d3.csv("data/air.csv");
    console.log(nyc);
    console.log(trees);
    console.log(air);

    // Compile air quality information
    var AirDict = {};
    air.forEach(d => {
        AirDict[d['community_district'] ] = d['particle_concentration'] 
    });

    function boroMap(d){
      if(parseInt(d.properties.boro_cd)<=112 && parseInt(d.properties.boro_cd)>=101)
      {
        return "Manhattan"
      }
      if(parseInt(d.properties.boro_cd)<=503 && parseInt(d.properties.boro_cd)>=501){
        return "Staten Island"
      }
      if(parseInt(d.properties.boro_cd)<=212 && parseInt(d.properties.boro_cd)>=201){
        return "The Bronx"
      }
      if(parseInt(d.properties.boro_cd)<=318 && parseInt(d.properties.boro_cd)>=301){
        return "Brooklyn"
      }
      if(parseInt(d.properties.boro_cd)<=414 && parseInt(d.properties.boro_cd)>=401){
        return "Queens"
      }
       else return "Undefined"
    };
    airExtent = d3.extent(air, d => Number(d['particle_concentration']));
    let airColorScale = d3.scaleLinear()
                          .domain(airExtent)
                          .range(['yellow','red']);
        
    // Create NYC map
    var projection = d3.geoAlbers().fitSize([mapWidth, mapHeight], nyc)
    const path = d3.geoPath(projection);

    var viewport = map.append("g");

    // diagonal patch pattern for undefined

    svg
      .append('defs')
      .append('pattern')
        .attr('id', 'diagonalHatch')
        .attr('patternUnits', 'userSpaceOnUse')
        .attr('width', 4)
        .attr('height', 4)
      .append('path')
        .attr('d', 'M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2')
        .attr('stroke', 'black')
        .attr('stroke-width', 1);
    var communities = viewport.selectAll("path.community")
      .data( nyc.features )
      .join("path")
      .attr("class", "community")
      .attr("stroke", "black")
      .style("stroke-width", 1)
      .attr("d", path)
      .attr("fill", function (d) { 
          // Manhattan: 101-112
          // Staten Island: 501-503
          // Bronx: 201-212
          // Brooklyn: 301-318
          // Queens: 401-414
          if(parseInt(d.properties.boro_cd)<=112 && parseInt(d.properties.boro_cd)>=101 ||
            parseInt(d.properties.boro_cd)<=503 && parseInt(d.properties.boro_cd)>=501 ||
            parseInt(d.properties.boro_cd)<=212 && parseInt(d.properties.boro_cd)>=201 ||
            parseInt(d.properties.boro_cd)<=318 && parseInt(d.properties.boro_cd)>=301 ||
            parseInt(d.properties.boro_cd)<=414 && parseInt(d.properties.boro_cd)>=401) 
              return airColorScale(AirDict[d.properties.boro_cd])
    
          else return "url(#diagonalHatch)"
      })
      .on('mouseover',  mouseEntersCommunity )
      .on('mouseout',  mouseLeavesCommunity );

    viewport.selectAll("circle.tree")
            .data(trees)
            .join("circle")
            .attr("class", "tree")
            .attr("r", 0.5)
            .attr("fill", "green")
            .attr("cx", d => projection([d["longitude"], d["latitude"]])[0])
            .attr("cy", d => projection([d["longitude"], d["latitude"]])[1]);

    // Zoom interaction
    var zoom = d3.zoom().scaleExtent([1,3]).on("zoom", mapZoomed);

    viewport.call(zoom);

    function mapZoomed({transform}) {     
      viewport.attr("transform", transform);
    }

    // Mouseover interaction
    let tooltip_scatter1 = viewport2.append("g")
                      .attr("class","circle")
                      .attr("visibility","hidden");
    let scatterplotCircle = tooltip_scatter1.append("circle")
                                              .attr('cx', 0)
                                              .attr('cy', 0)
                                              .attr('r', 5)
                                              .attr("stroke-width",3)
                                              .attr("stroke","black")
                                              .attr('fill-opacity', 0)

    let tooltip = map.append("g")
                      .attr("class","tooltip")
                      .attr("visibility","hidden");
    tooltip.append("rect")
            .attr("fill", "darkgreen")
            .attr("opacity", 1)
            .attr("x", -20)
            .attr("y", 0)
            .attr("width", 180)
            .attr("height", 70)
    let textbox = tooltip.append("text")
                      .text('halo')
                      .attr("fill", "white")
                      .attr("text-anchor","middle")
                      .attr("alignment-baseline","hanging")
                      .attr("x", 60)
                      .attr("y", 7);
    let textbox2 = tooltip.append("text")
                      .attr("fill", "white")
                      .attr("text-anchor","middle")
                      .attr("alignment-baseline","hanging")
                      .attr("x", 60)
                      .attr("y", 27);

    let textbox3 = tooltip.append("text")
                      .attr("fill", "white")
                      .attr("text-anchor","middle")
                      .attr("alignment-baseline","hanging")
                      .attr("x", 60)
                      .attr("y", 47);
    
    drawLegend("#colorLegend", airColorScale);


    function mouseEntersCommunity() {
      tooltip.style("visibility","visible")

      current = d3.select(this);
      current.style("stroke-width", 2)

      let title = d3.select(this).datum().properties.boro_cd;
      textbox.text("Community: " + title).attr("font-size","15px");
      textbox2.text("Air Particles: " + String(AirDict[title]).slice(0, 5)).attr("font-size","15px");

      let boro = boroMap(d3.select(this).datum())
      textbox3.text("Borough: " + boro).attr("font-size","15px")

      let bounds = path.bounds( current.datum() )
      let xPos = (bounds[0][0]+bounds[1][0])/2.0 + 50;
      let yPos = (bounds[1][1] - 50);
      tooltip.attr("transform",`translate(${xPos},${yPos})`);

      //scatterplot interaction
      
      let xPos1 = treeScale(blockTreeNum[title.toString()]);
      let yPos1 = popScale(Number(blockPopulation[title.toString()]));
      console.log(blockTreeNum[title.toString()],Number(blockPopulation[title.toString()]))
      if (xPos1!=undefined && yPos1 !=undefined)
      {
        scatterplotCircle.style("visibility","visible")
        tooltip_scatter1.attr("transform",`translate(${xPos1},${yPos1})`);
      
      }

    }

  function mouseLeavesCommunity() {
      tooltip.style("visibility","hidden")
      textbox.html('');
      textbox2.html('');

      current = d3.select(this);
      current.style("stroke-width", 1)
      //scatterplot1
      scatterplotCircle.style("visibility","hidden")
    };

  //from Lecture 22.10.03 notes 
  function drawLegend(legendSelector, legendColorScale) {
    
    // This code should adapt to a variety of different kinds of color scales
    //  Credit Prof. Rz if you are basing a legend on this structure, and note PERFORMANCE CONSIDERATIONS
    
    // Shrink legend bar by 5 px inwards from sides of SVG
    const offsets = { width: 10,
                      top: 2,
                      bottom: 24 }; 
    // Number of integer 'pixel steps' to draw when showing continuous scales
    //    Warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance -- keep this large
    const stepSize = 4; 
    // Extend the minmax by 0% in either direction to expose more features by default
    const minMaxExtendPercent = 0;
    
    
    const legend = d3.select(legendSelector);
    const legendHeight = legend.attr("height");
    const legendBarWidth = legend.attr("width") - (offsets.width * 2);
    const legendMinMax = d3.extent(legendColorScale.domain()); 
                // recover the min and max values from most kinds of numeric scales
    const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
    const barHeight = legendHeight - offsets.top - offsets.bottom;     
    
    // In this case the "data" are pixels, and we get numbers to use in colorScale
    // Use this to make axis labels
    let barScale = d3.scaleLinear().domain([legendMinMax[0]-minMaxExtension,
                                              legendMinMax[1]+minMaxExtension])
                                  .range([0,legendBarWidth]);
    let barAxis = d3.axisBottom(barScale);
    
    // Place for bar slices to live
    let bar = legend.append("g")
                    .attr("class", "legend colorbar")
                    .attr("transform", `translate(${offsets.width},${offsets.top})`)
    
    // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******
    
    // Check if we're using a binning scale - if so, we make blocks of color
    if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
      // Get the thresholds
      let thresholds = [];
      if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
      else { thresholds = legendColorScale.quantiles() }
      
      const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];
      
      // Use the quantile breakpoints plus the min and max of the scale as tick values
      barAxis.tickValues(barThresholds);
      
      // Draw rectangles between the threshold segments
      for (let i=0; i<barThresholds.length-1; i++) {
        let dataStart = barThresholds[i];
        let dataEnd = barThresholds[i+1];
        let pixelStart = barAxis.scale()(dataStart);
        let pixelEnd = barAxis.scale()(dataEnd);
        
        bar.append("rect")
          .attr("x", pixelStart)
          .attr("y", 0)
          .attr("width", pixelEnd - pixelStart )
          .attr("height", barHeight)
          .style("fill", legendColorScale( (dataStart + dataEnd) / 2.0 ) ); 
      }
    }
    // Else if we have a continuous / roundable scale
    else if (legendColorScale.hasOwnProperty('rangeRound')) {
      // NOTE: The barAxis may round min and max values to make them pretty
      // ** This also means there is a risk of the legend going beyond scale bounds
      // We need to use the barAxis min and max just to be sure the bar is complete
      //    Using barAxis.scale().invert() goes from *axis* pixels to data values easily
      // ** We also need to create patches for the scale if the labels exceed bounds
      //     (floating point comparisons risky for small data ranges,but not a big deal
      //      because patches will be indistinguishable from actual scale bottom)
      // It's likely that scale clamping will actually do this for us elegantly
      // ...but better to be safer and patch the regions anyways
      
      for (let i=0; i<legendBarWidth; i=i+stepSize) {
        
        let center = i+(stepSize/2);
        let dataCenter = barAxis.scale().invert( center );
        
        // below normal scale bounds
        if ( dataCenter < legendMinMax[0] ) { 
          bar.append("rect")
            .attr("x", i)
            .attr("y", 0)
            .attr("width", stepSize)
            .attr("height",barHeight)
            .style("fill", legendColorScale( legendMinMax[0] ) ); 
        }
        // within normal scale bounds
        else if ( dataCenter < legendMinMax[1] ) {
          bar.append("rect")
              .attr("x", i)
              .attr("y", 0)
              .attr("width", stepSize)
              .attr("height",barHeight)
              .style("fill", legendColorScale( dataCenter ) ); 
        }
        // above normal scale bounds
        else {
          bar.append("rect")
              .attr("x", i)
              .attr("y", 0)
              .attr("width", stepSize)
              .attr("height",barHeight)
              .style("fill", legendColorScale( legendMinMax[1] ) ); 
        }
        
      }
    }
    // Otherwise we have a nominal scale
    else {
      let nomVals = legendColorScale.domain().sort();
      
      // Use a scaleBand to make blocks of color and simple labels
      let barScale = d3.scaleBand().domain(nomVals)
                                  .range([0,legendBarWidth])
                                  .padding(0.05);
      barAxis.scale(barScale);
      
      // Draw rectangles for each nominal entry
      nomVals.forEach( d => {
        bar.append("rect")
          .attr("x", barScale(d) )
          .attr("y", 0)
          .attr("width", barScale.bandwidth() )
          .attr("height", barHeight)
          .style("fill", legendColorScale( d ) );
      });
    }
    // DONE w/SWITCH
    
    // Finally, draw legend labels
    legend.append("g")
          .attr("class", "legend axis")
          .attr("transform",`translate(${offsets.width},${offsets.top+barHeight+5})`)
          .call(barAxis);
    
  }
  };

  requestData();
</script>



</html>